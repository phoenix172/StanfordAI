@page "/data"
@using System.Collections.Immutable
@using AnomalyDetection.Client.Components
@using Plotly.Blazor
@using Plotly.Blazor.Traces
@using Plotly.Blazor.Traces.ScatterLib
@using System.Reflection
@using System.Collections.Immutable
@using AnomalyDetection.Core
@using MathNet.Numerics.LinearAlgebra
@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.Traces.ContourLib
@using Plotly.Blazor.Traces.ContourLib.ContoursLib
@using Plotly.Blazor.Traces.ScatterLib.MarkerLib
@using HoverInfoFlag = Plotly.Blazor.Traces.ScatterLib.HoverInfoFlag
@rendermode @(new InteractiveAutoRenderMode(prerender: true))
@inject IAnomalyDetector Detector

<script src="_content/Plotly.Blazor/plotly-latest.min.js" type="text/javascript"></script>
<script src="_content/Plotly.Blazor/plotly-interop.js" type="text/javascript"></script>

<MudGrid>
    <MudItem xs="12" md="6">
        @if (_loaded)
        {
            <ChartComponent Data="_trainingScatter" Title="Training Data Scatter Plot" />
            <ChartComponent Data="_featurePlotX" Title="X Feature Plot" />
            <ChartComponent Data="_featurePlotY" Title="Y Feature Plot" />
            <ChartComponent Data="_contourPlot" Title="Gaussian Distribution Probability Levels Contour Plot" />
        }
    </MudItem>
</MudGrid>



@code {
    private List<ITrace>? _trainingScatter;
    private List<ITrace>? _contourPlot;
    private bool _loaded = false;
    private List<ITrace>? _featurePlotX;
    private List<ITrace>? _featurePlotY;


    protected override async Task OnInitializedAsync()
    {
        await Detector.LoadFrom("Data/Part1");

        _trainingScatter = [MakeTrainingScatter()];

        _contourPlot = [_trainingScatter[0], MakeContourPlot()];
        _featurePlotX = [MakeFeatureHistogram(Detector.TrainingData.EnumerateColumns().First())];
        _featurePlotY = [MakeFeatureHistogram(Detector.TrainingData.EnumerateColumns().Last())];
        _loaded = true;
        await base.OnInitializedAsync();
    }

    private Contour MakeContourPlot()
    {
        var x1Values = VectorArrange(0, 35.5, 0.5);
        var x2Values = VectorArrange(0, 35.5, 0.5);
        var data = Matrix<double>.Build.DenseOfColumnVectors(x1Values, x2Values);

        var parameters = Detector.EstimateGaussianParameters();
        var distribution = Detector.MultivariateGaussian(parameters  with {Data = data} );
        IList<object> zColumn = distribution.Cast<object>().ToList();

        var contour =  new Contour
        {
                X = VectorArrange(0, 35.5, 0.5).Cast<object>().ToArray(),/* data.Column(0).Cast<object>().ToArray(), */
                Y = VectorArrange(0, 35.5, 0.5).Cast<object>().ToArray(),/* data.Column(1).Cast<object>().ToArray(), */
            Z = zColumn,
             Contours = new Contours(){
                 Start=(decimal)Math.Pow(10,-20),
                 End= (decimal)Math.Pow(10,1),
                 Size = (decimal)Math.Pow(10,3),
                 Type = TypeEnum.Levels
             },
                // AutoContour = false,
                // ZMin = (decimal)Math.Pow(10, -20),
                // ZMax = (decimal)Math.Pow(10, 1)
        };

        return contour;
    }

    private Histogram MakeFeatureHistogram(Vector<double> feature)
    {
        var column = feature.Cast<object>().ToList();
        return new Histogram
        {
            X = column,
            HoverInfo = Plotly.Blazor.Traces.HistogramLib.HoverInfoFlag.All
        };
    }

    private Scatter MakeTrainingScatter()
    {
        var columns = Detector.TrainingData.EnumerateColumns().ToImmutableArray();
        IList<object> xColumn = columns[0].Cast<object>().ToList();
        IList<object> yColumn = columns[1].Cast<object>().ToList();

        return
            new Scatter
                {
                    Name = "Scatter",
                    Mode = ModeFlag.Markers,
                    Marker = new Marker()
                    {
                        Symbol = SymbolEnum.Cross,
                        Color = Colors.Blue.Accent1,
                        Size = 12
                    },
                    X = xColumn,
                    Y = yColumn,
                    HoverInfo = HoverInfoFlag.X | HoverInfoFlag.Y,
                    HoverOn = HoverOnFlag.Points
                };
    }

    private static Vector<double> VectorArrange(double start, double end, double step)
    {
        int size = (int)((end - start) / step);
        var steps = Enumerable.Range(0, size).Select(x => x * step);
        return Vector<double>.Build.DenseOfEnumerable(steps);

        var contourRange = Vector<double>.Build.DenseOfEnumerable(Enumerable.Range(-20 / 3, (1 - (-20)) / 3) // Generate numbers from -20/3 to 1/3
            .Select(x => x * 3d));
    }

}
